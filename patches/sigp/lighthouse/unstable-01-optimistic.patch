diff --git a/beacon_node/beacon_chain/src/fetch_blobs/fetch_blobs_beacon_adapter.rs b/beacon_node/beacon_chain/src/fetch_blobs/fetch_blobs_beacon_adapter.rs
index 9526921..b558fd6 100644
--- a/beacon_node/beacon_chain/src/fetch_blobs/fetch_blobs_beacon_adapter.rs
+++ b/beacon_node/beacon_chain/src/fetch_blobs/fetch_blobs_beacon_adapter.rs
@@ -39,6 +39,11 @@ impl<T: BeaconChainTypes> FetchBlobsBeaconAdapter<T> {
         &self,
         versioned_hashes: Vec<Hash256>,
     ) -> Result<Vec<Option<BlobAndProofV1<T::EthSpec>>>, FetchEngineBlobError> {
+        // In optimistic mode, return no blobs since we have no EL
+        if std::env::var("LIGHTHOUSE_OPTIMISTIC").is_ok() {
+            return Ok(vec![None; versioned_hashes.len()]);
+        }
+
         let execution_layer = self
             .chain
             .execution_layer
@@ -55,6 +60,11 @@ impl<T: BeaconChainTypes> FetchBlobsBeaconAdapter<T> {
         &self,
         versioned_hashes: Vec<Hash256>,
     ) -> Result<Option<Vec<BlobAndProofV2<T::EthSpec>>>, FetchEngineBlobError> {
+        // In optimistic mode, return empty blobs since we have no EL
+        if std::env::var("LIGHTHOUSE_OPTIMISTIC").is_ok() {
+            return Ok(Some(vec![]));
+        }
+
         let execution_layer = self
             .chain
             .execution_layer
diff --git a/beacon_node/execution_layer/src/engines.rs b/beacon_node/execution_layer/src/engines.rs
index cc2bfcc..8d324cb 100644
--- a/beacon_node/execution_layer/src/engines.rs
+++ b/beacon_node/execution_layer/src/engines.rs
@@ -232,6 +232,16 @@ impl Engine {
     /// Run the `EngineApi::upcheck` function if the node's last known state is not synced. This
     /// might be used to recover the node if offline.
     pub async fn upcheck(&self) {
+        // In optimistic mode, always report as synced without contacting EL
+        if std::env::var("LIGHTHOUSE_OPTIMISTIC").is_ok() {
+            let mut state = self.state.write().await;
+            if **state != EngineStateInternal::Synced {
+                info!("Optimistic mode: marking execution engine as synced (no EL required)");
+            }
+            state.update(EngineStateInternal::Synced);
+            return;
+        }
+
         let (state, cache_action) = match self.api.upcheck().await {
             Ok(()) => {
                 let mut state = self.state.write().await;
diff --git a/beacon_node/execution_layer/src/lib.rs b/beacon_node/execution_layer/src/lib.rs
index 34b1832..ba3af5e 100644
--- a/beacon_node/execution_layer/src/lib.rs
+++ b/beacon_node/execution_layer/src/lib.rs
@@ -69,6 +69,12 @@ mod payload_status;
 pub mod test_utils;
 pub mod versioned_hashes;
 
+/// Check if optimistic mode is enabled via environment variable.
+/// In optimistic mode, all EL calls are bypassed and blocks are accepted as valid.
+fn is_optimistic_mode() -> bool {
+    std::env::var("LIGHTHOUSE_OPTIMISTIC").is_ok()
+}
+
 /// Indicates the default jwt authenticated execution endpoint.
 pub const DEFAULT_EXECUTION_ENDPOINT: &str = "http://localhost:8551/";
 
@@ -1372,6 +1378,11 @@ impl<E: EthSpec> ExecutionLayer<E> {
         &self,
         new_payload_request: NewPayloadRequest<'_, E>,
     ) -> Result<PayloadStatus, Error> {
+        // Bypass EL validation in optimistic mode
+        if is_optimistic_mode() {
+            return Ok(PayloadStatus::Valid);
+        }
+
         let _timer = metrics::start_timer_vec(
             &metrics::EXECUTION_LAYER_REQUEST_TIMES,
             &[metrics::NEW_PAYLOAD],
@@ -1480,6 +1491,11 @@ impl<E: EthSpec> ExecutionLayer<E> {
         current_slot: Slot,
         head_block_root: Hash256,
     ) -> Result<PayloadStatus, Error> {
+        // Bypass EL forkchoice in optimistic mode
+        if is_optimistic_mode() {
+            return Ok(PayloadStatus::Syncing);
+        }
+
         let _timer = metrics::start_timer_vec(
             &metrics::EXECUTION_LAYER_REQUEST_TIMES,
             &[metrics::FORKCHOICE_UPDATED],
diff --git a/beacon_node/src/cli.rs b/beacon_node/src/cli.rs
index 049e61c..cb18e9b 100644
--- a/beacon_node/src/cli.rs
+++ b/beacon_node/src/cli.rs
@@ -261,6 +261,16 @@ pub fn cli_app() -> Command {
                 .action(ArgAction::Set)
                 .display_order(0)
         )
+        .arg(
+            Arg::new("optimistic")
+                .long("optimistic")
+                .action(ArgAction::SetTrue)
+                .help_heading(FLAG_HEADER)
+                .help("Enables optimistic mode by bypassing execution engine validation. \
+                       Lighthouse will accept all blocks as valid without an execution client. \
+                       WARNING: This disables critical safety checks - use only for testing/observation.")
+                .display_order(0)
+        )
         .arg(
             Arg::new("disable-upnp")
                 .long("disable-upnp")
diff --git a/lighthouse/src/main.rs b/lighthouse/src/main.rs
index d2cde68..49bee3c 100644
--- a/lighthouse/src/main.rs
+++ b/lighthouse/src/main.rs
@@ -421,12 +421,18 @@ fn main() {
     let matches = cli.get_matches();
 
     // Set XATU_CONFIG environment variable early if xatu-config is provided
+    // Set LIGHTHOUSE_OPTIMISTIC environment variable if --optimistic flag is set
     if let Some(("beacon_node", bn_matches)) = matches.subcommand() {
         if let Some(xatu_config_path) = bn_matches.get_one::<String>("xatu-config") {
             unsafe {
                 std::env::set_var("XATU_CONFIG", xatu_config_path);
             }
         }
+        if bn_matches.get_flag("optimistic") {
+            unsafe {
+                std::env::set_var("LIGHTHOUSE_OPTIMISTIC", "1");
+            }
+            eprintln!("WARNING: Optimistic mode enabled - execution engine validation is bypassed");
+        }
     }
 
     // Configure the allocator early in the process, before it has the chance to use the default values for
