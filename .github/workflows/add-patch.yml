name: Add New Patch

on:
  workflow_dispatch:
    inputs:
      repository:
        description: 'Repository (format: org/repo)'
        required: true
        type: string
        default: 'sigp/lighthouse'
      ref:
        description: 'Branch, tag, or commit hash'
        required: true
        type: string
        default: 'unstable'
      patch_name:
        description: 'Optional: Custom patch filename (defaults to ref name)'
        required: false
        type: string
      force_rebuild:
        description: 'Force rebuild even if patch already exists'
        required: false
        default: false
        type: boolean

jobs:
  add-patch:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Validate inputs
        id: validate
        run: |
          # Validate repository format
          if ! echo "${{ github.event.inputs.repository }}" | grep -qE '^[^/]+/[^/]+$'; then
            echo "Error: Repository must be in format 'org/repo'"
            exit 1
          fi
          
          # Extract org and repo
          ORG=$(echo "${{ github.event.inputs.repository }}" | cut -d'/' -f1)
          REPO=$(echo "${{ github.event.inputs.repository }}" | cut -d'/' -f2)
          REF="${{ github.event.inputs.ref }}"
          
          # Determine patch filename
          if [ -n "${{ github.event.inputs.patch_name }}" ]; then
            PATCH_NAME="${{ github.event.inputs.patch_name }}"
            # Ensure it ends with .patch
            if [[ ! "$PATCH_NAME" == *.patch ]]; then
              PATCH_NAME="${PATCH_NAME}.patch"
            fi
          else
            # Use ref as patch name, sanitize it (replace / with -)
            PATCH_NAME="${REF//\//-}.patch"
          fi
          
          echo "org=$ORG" >> $GITHUB_OUTPUT
          echo "repo=$REPO" >> $GITHUB_OUTPUT
          echo "ref=$REF" >> $GITHUB_OUTPUT
          echo "patch_name=$PATCH_NAME" >> $GITHUB_OUTPUT
          
          # Check if patch already exists
          PATCH_PATH="patches/$ORG/$REPO/$PATCH_NAME"
          if [ -f "$PATCH_PATH" ] && [ "${{ github.event.inputs.force_rebuild }}" != "true" ]; then
            echo "Error: Patch already exists at $PATCH_PATH"
            echo "Set 'Force rebuild' to true to overwrite"
            exit 1
          fi
          
          echo "patch_path=$PATCH_PATH" >> $GITHUB_OUTPUT
      
      - name: Set up Rust
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
      
      - name: Cache cargo registry
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-${{ steps.validate.outputs.org }}-${{ steps.validate.outputs.repo }}-${{ steps.validate.outputs.ref }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-${{ steps.validate.outputs.org }}-${{ steps.validate.outputs.repo }}-
            ${{ runner.os }}-cargo-
      
      - name: Clone target repository
        run: |
          echo "Cloning ${{ github.event.inputs.repository }} at ref ${{ steps.validate.outputs.ref }}"
          
          # Try to clone with the ref as a branch first
          if git clone --depth 1 --branch "${{ steps.validate.outputs.ref }}" \
               "https://github.com/${{ github.event.inputs.repository }}.git" lighthouse 2>/dev/null; then
            echo "Successfully cloned branch/tag: ${{ steps.validate.outputs.ref }}"
          else
            # If that fails, it might be a commit hash
            echo "Ref might be a commit hash, cloning default branch first..."
            git clone "https://github.com/${{ github.event.inputs.repository }}.git" lighthouse
            cd lighthouse
            
            # Try to checkout the specific commit
            if git checkout "${{ steps.validate.outputs.ref }}" 2>/dev/null; then
              echo "Successfully checked out commit: ${{ steps.validate.outputs.ref }}"
            else
              # Try to fetch the ref first (might be a remote branch not in default clone)
              echo "Fetching ref from remote..."
              git fetch origin "${{ steps.validate.outputs.ref }}"
              git checkout "${{ steps.validate.outputs.ref }}"
            fi
            cd ..
          fi
          
          # Get the actual commit hash for documentation
          cd lighthouse
          COMMIT_HASH=$(git rev-parse --short HEAD)
          FULL_COMMIT_HASH=$(git rev-parse HEAD)
          cd ..
          
          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_ENV
          echo "full_commit_hash=$FULL_COMMIT_HASH" >> $GITHUB_ENV
      
      - name: Create initial patch using default
        run: |
          echo "Creating initial patch based on default (sigp/lighthouse/unstable)"
          
          # Ensure the patches directory exists
          mkdir -p "$(dirname ${{ steps.validate.outputs.patch_path }})"
          
          # Copy the default patch as a starting point if it exists
          if [ -f "patches/sigp/lighthouse/unstable.patch" ]; then
            echo "Using default patch as template..."
            cp "patches/sigp/lighthouse/unstable.patch" "${{ steps.validate.outputs.patch_path }}"
          else
            echo "No default patch found, will create from scratch"
            # Create an empty patch file so the build script knows to create a new one
            touch "${{ steps.validate.outputs.patch_path }}"
          fi
      
      - name: Run dimhouse build
        id: build
        run: |
          echo "Building ${{ steps.validate.outputs.org }}/${{ steps.validate.outputs.repo }} with ref ${{ steps.validate.outputs.ref }}"
          
          # Clean up the lighthouse directory first
          rm -rf lighthouse
          
          # Run the build script in CI mode
          # Note: We use the ref as the "branch" parameter, the script will handle it appropriately
          ./dimhouse-build.sh \
            -r "${{ steps.validate.outputs.org }}/${{ steps.validate.outputs.repo }}" \
            -b "${{ steps.validate.outputs.ref }}" \
            --ci
          
          # The script should have created/updated the patch file
          if [ -f "${{ steps.validate.outputs.patch_path }}" ] && [ -s "${{ steps.validate.outputs.patch_path }}" ]; then
            echo "Patch created/updated successfully"
            echo "patch_created=true" >> $GITHUB_OUTPUT
          else
            echo "Failed to create patch"
            echo "patch_created=false" >> $GITHUB_OUTPUT
            exit 1
          fi
      
      - name: Commit new patch
        if: steps.build.outputs.patch_created == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          git add "${{ steps.validate.outputs.patch_path }}"
          
          COMMIT_MSG="Add patch for ${{ steps.validate.outputs.org }}/${{ steps.validate.outputs.repo }} ${{ steps.validate.outputs.ref }}

          Repository: ${{ github.event.inputs.repository }}
          Ref: ${{ steps.validate.outputs.ref }}
          Commit: ${{ env.full_commit_hash }}
          
          Triggered by: @${{ github.actor }}"
          
          git commit -m "$COMMIT_MSG"
          git push
      
      - name: Create release
        if: steps.build.outputs.patch_created == 'true'
        run: |
          # Create tag name
          TAG_NAME="${{ steps.validate.outputs.org }}-${{ steps.validate.outputs.repo }}-${{ steps.validate.outputs.ref }}-${{ env.commit_hash }}"
          # Sanitize tag name (replace / with -)
          TAG_NAME="${TAG_NAME//\//-}"
          
          # Create release notes
          RELEASE_BODY="New patch for ${{ steps.validate.outputs.org }}/${{ steps.validate.outputs.repo }}

          Reference: ${{ steps.validate.outputs.ref }}
          Commit: ${{ env.full_commit_hash }}
          Patch file: ${{ steps.validate.outputs.patch_path }}
          
          This patch was manually added by @${{ github.actor }}
          
          To apply this patch:
          \`\`\`bash
          ./apply-dimhouse-patch.sh ${{ steps.validate.outputs.org }}/${{ steps.validate.outputs.repo }} ${{ steps.validate.outputs.ref }}
          \`\`\`"
          
          # Create the release
          gh release create "$TAG_NAME" \
            --title "New Patch: ${{ steps.validate.outputs.org }}/${{ steps.validate.outputs.repo }} ${{ steps.validate.outputs.ref }}" \
            --notes "$RELEASE_BODY" \
            "${{ steps.validate.outputs.patch_path }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Summary
        if: always()
        run: |
          echo "## Patch Addition Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.build.outputs.patch_created }}" == "true" ]; then
            echo "✅ **Successfully added patch**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Repository:** ${{ github.event.inputs.repository }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Reference:** ${{ steps.validate.outputs.ref }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Commit:** \`${{ env.full_commit_hash }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Patch file:** \`${{ steps.validate.outputs.patch_path }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Usage" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "./apply-dimhouse-patch.sh ${{ steps.validate.outputs.org }}/${{ steps.validate.outputs.repo }} ${{ steps.validate.outputs.ref }}" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Failed to add patch**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check the workflow logs for details." >> $GITHUB_STEP_SUMMARY
          fi