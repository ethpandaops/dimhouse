name: Validate Patch Files

on:
  push:
    paths:
      - 'patches/**/*.patch'
  pull_request:
    paths:
      - 'patches/**/*.patch'

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Validate all patch files
        run: |
          set -e

          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          NC='\033[0m'

          # Validate a patch file structure
          validate_patch_file() {
              local patch_file="$1"
              local errors=()

              # Check file exists and is readable
              if [ ! -r "$patch_file" ]; then
                  echo "Patch file not readable: $patch_file"
                  return 1
              fi

              # Check file is not empty
              if [ ! -s "$patch_file" ]; then
                  echo "Patch file is empty: $patch_file"
                  return 1
              fi

              # Check file ends with a newline
              if [ "$(tail -c 1 "$patch_file" | xxd -p)" != "0a" ]; then
                  errors+=("Missing newline at end of file")
              fi

              # Validate each hunk header matches content
              local in_hunk=false
              local expected_old=0
              local expected_new=0
              local actual_old=0
              local actual_new=0
              local hunk_start_line=0
              local line_num=0

              while IFS= read -r line || [ -n "$line" ]; do
                  ((line_num++))

                  # Check for hunk header
                  if [[ "$line" =~ ^@@[[:space:]]-([0-9]+),([0-9]+)[[:space:]]\+([0-9]+),([0-9]+)[[:space:]]@@.* ]]; then
                      # Validate previous hunk if there was one
                      if [ "$in_hunk" = true ]; then
                          if [ "$actual_old" -ne "$expected_old" ]; then
                              errors+=("Hunk at line $hunk_start_line: expected $expected_old old lines, got $actual_old")
                          fi
                          if [ "$actual_new" -ne "$expected_new" ]; then
                              errors+=("Hunk at line $hunk_start_line: expected $expected_new new lines, got $actual_new")
                          fi
                      fi

                      # Start new hunk
                      in_hunk=true
                      hunk_start_line=$line_num
                      expected_old="${BASH_REMATCH[2]}"
                      expected_new="${BASH_REMATCH[4]}"
                      actual_old=0
                      actual_new=0
                  elif [ "$in_hunk" = true ]; then
                      # Count lines in hunk
                      if [[ "$line" =~ ^[[:space:]] ]] || [[ "$line" == "" ]]; then
                          # Context line (counts for both)
                          ((actual_old++))
                          ((actual_new++))
                      elif [[ "$line" =~ ^\+ ]]; then
                          # Added line
                          ((actual_new++))
                      elif [[ "$line" =~ ^- ]]; then
                          # Removed line
                          ((actual_old++))
                      elif [[ "$line" =~ ^diff|^index|^---|^\+\+\+ ]]; then
                          # New file header - validate previous hunk
                          if [ "$actual_old" -ne "$expected_old" ]; then
                              errors+=("Hunk at line $hunk_start_line: expected $expected_old old lines, got $actual_old")
                          fi
                          if [ "$actual_new" -ne "$expected_new" ]; then
                              errors+=("Hunk at line $hunk_start_line: expected $expected_new new lines, got $actual_new")
                          fi
                          in_hunk=false
                      fi
                  fi
              done < "$patch_file"

              # Validate final hunk
              if [ "$in_hunk" = true ]; then
                  if [ "$actual_old" -ne "$expected_old" ]; then
                      errors+=("Hunk at line $hunk_start_line: expected $expected_old old lines, got $actual_old")
                  fi
                  if [ "$actual_new" -ne "$expected_new" ]; then
                      errors+=("Hunk at line $hunk_start_line: expected $expected_new new lines, got $actual_new")
                  fi
              fi

              if [ ${#errors[@]} -gt 0 ]; then
                  echo -e "${RED}✗ Patch file validation failed: $patch_file${NC}"
                  for err in "${errors[@]}"; do
                      echo -e "${RED}  - $err${NC}"
                  done
                  return 1
              fi

              return 0
          }

          # Find and validate all patch files
          FAILED=0
          PASSED=0

          for patch in $(find patches -name "*.patch" -type f | sort); do
              echo -n "Validating $patch... "
              if validate_patch_file "$patch"; then
                  echo -e "${GREEN}✓ valid${NC}"
                  PASSED=$((PASSED + 1))
              else
                  FAILED=$((FAILED + 1))
              fi
          done

          echo ""
          echo "=== Summary ==="
          echo -e "${GREEN}Passed: $PASSED${NC}"
          if [ $FAILED -gt 0 ]; then
              echo -e "${RED}Failed: $FAILED${NC}"
              exit 1
          else
              echo "All patch files are valid!"
          fi
